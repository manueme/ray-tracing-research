/*
 * Manuel Machado Copyright (C) 2021 This code is licensed under the MIT license (MIT)
 * (http://opensource.org/licenses/MIT)
 */

#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "../../framework/shaders/constants.h"
#include "../../framework/shaders/definitions.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(location = RT_PAYLOAD_SHADOW) rayPayloadEXT RayPayloadShadow rayPayloadShadow;

layout(binding = 0, set = 4) buffer _Lights { LightProperties l[]; }
lighting;

layout(binding = 0, set = 5, rgba32f) uniform image2D inputColor;
layout(binding = 1, set = 5, rgba32f) uniform image2D inputNormals;
layout(binding = 2, set = 5, r32f) uniform image2D inputDepth;
layout(binding = 3, set = 5, rgba32f) uniform image2D resultImage;

layout(binding = 0, set = 1) uniform _SceneProperties
{
    mat4 viewInverse;
    mat4 projInverse;
    vec4 overrideSunDirection;
}
scene;

float trace_shadow_ray(vec3 origin, vec3 direction, int instanceMask, float maxDistance)
{
    const uint rayFlags = gl_RayFlagsTerminateOnFirstHitEXT;
    rayPayloadShadow.shadowAmount = 0.0f;
    traceRayEXT(topLevelAS,
        rayFlags,
        instanceMask,
        SBT_MC_SHADOW_HIT_GROUP /*sbtRecordOffset*/,
        0 /*sbtRecordStride*/,
        SBT_MC_SHADOW_MISS_INDEX /*missIndex*/,
        origin,
        RAY_MIN_HIT,
        direction,
        maxDistance,
        RT_PAYLOAD_SHADOW);
    return rayPayloadShadow.shadowAmount;
}

void main()
{
    vec3 result = imageLoad(inputColor, ivec2(gl_LaunchIDEXT.xy)).rbg;
    const vec2 inUV = vec2(gl_LaunchSizeEXT.xy);
    const vec2 thetaOut = inUV * 2.0f - 1.0f;
    const vec4 target = scene.projInverse * vec4(thetaOut.x, thetaOut.y, 1.0f, 1.0f);
    // Initial Origin and Direction
    const float surfaceDepth = imageLoad(inputDepth, ivec2(gl_LaunchIDEXT.xy)).r;
    vec3 hitPoint = vec3((scene.viewInverse * vec4(0.0f, 0.0f, 0.0f, 1.0f)).xy, surfaceDepth);
    const vec3 shadingNormal = imageLoad(inputNormals, ivec2(gl_LaunchIDEXT.xy)).rgb;
    // vec3 auxRirection = (scene.viewInverse * vec4(normalize(target.xyz / target.w), 0.0f)).xyz;
    // vec3 rayDirection = reflect(auxRirection, shadingNormal);
    for (int i = 0; i < lighting.l.length(); ++i) {
        const LightProperties light = lighting.l[i];
        vec3 lightDir = vec3(0.0f);
        vec3 lightIntensity = vec3(0.0f);
        float maxHitDistance = RAY_MAX_HIT;
        if (light.lightType == 1) { // Directional light (SUN)
            lightDir = light.direction.xyz + vec3(scene.overrideSunDirection);
            lightIntensity = light.diffuse.rgb * SUN_POWER;
            lightDir = normalize(lightDir);
        } else {
            continue;
        }

        const float cosThetaLight = abs(dot(shadingNormal, lightDir));
        if (cosThetaLight > 0) {
            const float visibility
                = (1.0 - trace_shadow_ray(hitPoint, -lightDir, AS_FLAG_EVERYTHING, maxHitDistance));
            result *= visibility * lightIntensity;
        }
    }

    imageStore(resultImage, ivec2(gl_LaunchIDEXT.xy), vec4(result, 1.0f));
}
