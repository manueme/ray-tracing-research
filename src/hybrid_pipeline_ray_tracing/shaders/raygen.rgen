/*
 * Manuel Machado Copyright (C) 2021 This code is licensed under the MIT license (MIT)
 * (http://opensource.org/licenses/MIT)
 */

#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "../../framework/shaders/common.glsl"
#include "../../framework/shaders/constants.h"
#include "../../framework/shaders/definitions.glsl"
#include "./hybrid_constants.h"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(location = RT_PAYLOAD_SHADOW) rayPayloadEXT RayPayloadShadow rayPayloadShadow;
layout(location = RT_PAYLOAD_BRDF) rayPayloadEXT RayPayload rayPayloadBRDF;

layout(binding = 0, set = 4) buffer _Lights { LightProperties l[]; }
lighting;

layout(binding = 0, set = 5) uniform sampler2D inputColor;
layout(binding = 1, set = 5) uniform sampler2D inputNormals;
layout(binding = 2, set = 5) uniform sampler2D inputReflectRefractMap;
layout(binding = 3, set = 5) uniform sampler2D inputDepth;
layout(binding = 0, set = 6, rgba8) uniform image2D resultImage;

layout(binding = 0, set = 1) uniform _SceneProperties
{
    mat4 projection;
    mat4 model;
    mat4 view;
    mat4 viewInverse;
    mat4 projInverse;
    vec4 overrideSunDirection;
    int frame;
}
scene;

layout(push_constant) uniform Constants
{
    int maxDepth;
    int samples;
};

float trace_shadow_ray(vec3 origin, vec3 direction, float maxDistance)
{
    const uint rayFlags = gl_RayFlagsTerminateOnFirstHitEXT;
    rayPayloadShadow.shadowAmount = 0.0f;
    traceRayEXT(topLevelAS,
        rayFlags,
        AS_FLAG_EVERYTHING,
        SBT_MC_SHADOW_HIT_GROUP /*sbtRecordOffset*/,
        0 /*sbtRecordStride*/,
        SBT_MC_SHADOW_MISS_INDEX /*missIndex*/,
        origin,
        CAMERA_NEAR,
        direction,
        maxDistance,
        RT_PAYLOAD_SHADOW);
    return rayPayloadShadow.shadowAmount;
}

void trace_ray(vec3 origin, vec3 direction)
{
    uint rayFlags = gl_RayFlagsNoneEXT;
    traceRayEXT(topLevelAS,
        rayFlags,
        AS_FLAG_EVERYTHING,
        SBT_MC_HIT_GROUP /*sbtRecordOffset*/,
        0 /*sbtRecordStride*/,
        SBT_MC_MISS_INDEX /*missIndex*/,
        origin,
        0.001f,
        direction,
        CAMERA_FAR,
        RT_PAYLOAD_BRDF);
}

float get_hit_depth(vec2 inUV)
{
    const float surfaceDepth = texture(inputDepth, inUV).x;
    const vec4 clipSpacePosition = vec4(inUV * 2.0f - 1.0f, surfaceDepth, 1.0f);
    vec4 viewSpacePosition = scene.projInverse * clipSpacePosition;
    viewSpacePosition /= viewSpacePosition.w;
    return length(viewSpacePosition.xyz);
}

void blendColors(in vec4 src, inout vec4 dst)
{
    float outR = 0.0;
    float srcR = src.x;
    float dstR = dst.x;

    float outG = 0.0;
    float srcG = src.y;
    float dstG = dst.y;

    float outB = 0.0;
    float srcB = src.z;
    float dstB = dst.z;

    float outA = 0.0;
    float srcA = src.w;
    float dstA = dst.w;

    outA = srcA + dstA * (1.0 - srcA);
    if (outA == 0.0) {
        dst = vec4(0.0, 0.0, 0.0, 0.0);
    } else {
        outR = (srcR * srcA + dstR * dstA * (1.0 - srcA)) / outA;
        outG = (srcG * srcA + dstG * dstA * (1.0 - srcA)) / outA;
        outB = (srcB * srcA + dstB * dstA * (1.0 - srcA)) / outA;
        dst = vec4(outR, outG, outB, outA);
    }
}

void main()
{
    // Initialize ray payload
    rayPayloadBRDF.seed
        = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, scene.frame);
    rayPayloadBRDF.done = 0;
    rayPayloadBRDF.surfaceAttenuation = vec3(1.0f);
    rayPayloadBRDF.surfaceRadiance = vec3(0.0f);
    rayPayloadBRDF.surfaceEmissive = vec3(0.0f);
    rayPayloadBRDF.rayType = RAY_TYPE_UNDEFINED;
    // ---

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5f);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);

    const vec2 thetaOut = inUV * 2.0f - 1.0f;
    const vec4 target = scene.projInverse * vec4(thetaOut.x, thetaOut.y, 1.0f, 1.0f);
    vec3 direction = (scene.viewInverse * vec4(normalize(target.xyz / target.w), 0.0f)).xyz;
    const float hitDepth = get_hit_depth(inUV);

    vec4 result = vec4(sky_ray(-direction), 1.0);

    if (hitDepth < CAMERA_FAR - CAMERA_NEAR) {
        vec3 origin = (scene.viewInverse * vec4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
        const vec3 hitPoint = origin + direction * hitDepth;
        vec3 shadingNormal = texture(inputNormals, inUV).xyz;
        const vec4 reflectRefractData = texture(inputReflectRefractMap, inUV).xyzw;
        float alphaWithoutRefractives = reflectRefractData.w;

        vec4 colorInformation = texture(inputColor, inUV);
        vec4 surfaceColor = vec4(colorInformation.xyz, alphaWithoutRefractives);
        vec4 surfaceEmissive = vec4(vec3(colorInformation.w), 0.0f);

        float reflectionPercent = reflectRefractData.x;
        float refractionPercent = reflectRefractData.y;
        float ior = reflectRefractData.z;
        vec3 refractions = vec3(0.0f);
        if (refractionPercent > 0.0f) { // REFRACT RAY
            vec3 refractionRayDirection = refract(direction, shadingNormal, ior);
            vec3 refractionPoint = hitPoint;
            if (!is_zero(refractionRayDirection)) {
                for (int depth = 1; depth < maxDepth; depth++) {
                    trace_ray(refractionPoint, refractionRayDirection);
                    if (rayPayloadBRDF.rayType == RAY_TYPE_DIFFUSE
                        || rayPayloadBRDF.rayType == RAY_TYPE_MISS) {
                        break;
                    }
                    refractionPoint = rayPayloadBRDF.nextRayOrigin;
                    refractionRayDirection = rayPayloadBRDF.nextRayDirection;
                }
                refractions = vec3(rayPayloadBRDF.surfaceEmissive + rayPayloadBRDF.surfaceRadiance)
                    * refractionPercent;
            } else {
                refractionPercent = 0.0f;
            }
        }
        vec3 reflections = vec3(0.0f);
        if (reflectionPercent > 0.0f) { // REFLECT RAY
            vec3 reflectionRayDirection = reflect(direction, shadingNormal);
            vec3 reflectionPoint = hitPoint;
            for (int depth = 1; depth < maxDepth; depth++) {
                trace_ray(reflectionPoint, reflectionRayDirection);
                if (rayPayloadBRDF.rayType == RAY_TYPE_DIFFUSE
                    || rayPayloadBRDF.rayType == RAY_TYPE_MISS) {
                    break;
                }
                reflectionPoint = rayPayloadBRDF.nextRayOrigin;
                reflectionRayDirection = rayPayloadBRDF.nextRayDirection;
            }
            reflections = vec3(rayPayloadBRDF.surfaceEmissive + rayPayloadBRDF.surfaceRadiance)
                * reflectionPercent;
        }

        vec3 reflectRefractResult = reflections + refractions;
        const float refractReflectComplement = (1.0f - (reflectionPercent + refractionPercent));

        if (refractReflectComplement > 0.0f) {
            float lightAmmount = AMBIENT_WEIGHT;
            for (int i = 0; i < lighting.l.length(); ++i) {
                const LightProperties light = lighting.l[i];
                vec3 lightDir = vec3(0.0f);
                float maxHitDistance = CAMERA_FAR;
                if (light.lightType == 1) { // Directional light (SUN)
                    lightDir = normalize(light.direction.xyz + vec3(scene.overrideSunDirection));
                } else {
                    continue;
                }
                const float lightVisibility
                    = 1.0f - trace_shadow_ray(hitPoint, -lightDir, maxHitDistance);
                lightAmmount += lightVisibility;
            }
            lightAmmount = min(lightAmmount, 1.0f);
            surfaceColor = vec4(
                surfaceColor.xyz * lightAmmount * refractReflectComplement + reflectRefractResult,
                surfaceColor.w);
        } else {
            surfaceColor = vec4(reflectRefractResult, 1.0f);
        }
        blendColors(surfaceEmissive + surfaceColor, result);
    }
    imageStore(resultImage, ivec2(gl_LaunchIDEXT.xy), result);
}
