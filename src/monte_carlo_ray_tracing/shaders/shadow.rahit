/*
 * Manuel Machado Copyright (C) 2021 This code is licensed under the MIT license (MIT)
 * (http://opensource.org/licenses/MIT)
 */

#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "../../framework/shaders/constants.h"
#include "../../framework/shaders/definitions.glsl"
#include "../../framework/shaders/vertex.glsl"

hitAttributeEXT vec3 attribs;
layout(location = RT_PAYLOAD_SHADOW_LOCATION) rayPayloadInEXT RayPayloadShadow rayPayloadShadow;
layout(binding = 0, set = 3) uniform sampler2D textures[];
layout(binding = 1, set = 3) buffer _Materials { MaterialProperties m[]; }
materials;

void main()
{
    const Surface hitSurface = get_surface_instance(gl_InstanceID, gl_PrimitiveID, attribs.xy);
    const uint materialIndex = instanceInfo.i[gl_InstanceID].materialIndex;
    const MaterialProperties material = materials.m[materialIndex];
    const vec2 uv = get_surface_uv(hitSurface);
    // #### ignore if it is a light ####
    if (material.emissiveMapIndex >= 0
        && texture(textures[nonuniformEXT(materiawl.emissiveMapIndex)], uv).r > 0.5f) {
        ignoreIntersectionEXT;
        return;
    } else if (material.emissive.r > 0.5f) {
        ignoreIntersectionEXT;
        return;
    }
    // #### or partially ignore if it is transparent ####
    float transparency;
    if (material.diffuseMapIndex >= 0) {
        transparency = rayPayloadShadow.shadowAmount
            + texture(textures[nonuniformEXT(material.diffuseMapIndex)], uv).w;
    } else {
        transparency = rayPayloadShadow.shadowAmount + material.opacity;
    }

    if (transparency >= 1.0) {
        rayPayloadShadow.shadowAmount = 1.0;
    } else {
        rayPayloadShadow.shadowAmount += transparency;
        ignoreIntersectionEXT;
    }
}