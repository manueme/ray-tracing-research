/*
 * Manuel Machado Copyright (C) 2021 This code is licensed under the MIT license (MIT)
 * (http://opensource.org/licenses/MIT)
 */

#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "../../framework/shaders/common.glsl"
#include "../../framework/shaders/constants.h"
#include "../../framework/shaders/definitions.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(location = RT_PAYLOAD_BRDF) rayPayloadEXT RayPayload rayPayloadBRDF;

// #define SAMPLE_PRIMARY
#define DEPTH_OF_FIELD
#define USE_DEPTH_MAP
#define SHOW_NANS

layout(binding = 0, set = 5, rgba32f) uniform image2D imageColor;
#ifdef USE_DEPTH_MAP
layout(binding = 1, set = 5, r32f) uniform image2D imageDepth;
#endif
layout(binding = 2, set = 5, rgba8) uniform image2D imageFirstSample;

layout(binding = 0, set = 1) uniform _SceneProperties
{
    mat4 viewInverse;
    mat4 projInverse;
    vec4 overrideSunDirection;
    int frameIteration;
    int frame;
    int frameChanged;
}
scene;

layout(push_constant) uniform Constants
{
    int maxDepth;
    int samples;
};

void trace_ray(vec3 origin, vec3 direction, int instanceMask)
{
    uint rayFlags = gl_RayFlagsNoneEXT;
    traceRayEXT(topLevelAS,
        rayFlags,
        instanceMask,
        SBT_MC_HIT_GROUP /*sbtRecordOffset*/,
        0 /*sbtRecordStride*/,
        SBT_MC_MISS_INDEX /*missIndex*/,
        origin,
        RAY_MIN_HIT,
        direction,
        RAY_MAX_HIT,
        RT_PAYLOAD_BRDF);
}

const float CAMERA_APERTURE = 0.75;
const float RAY_DISTANCE = RAY_MAX_HIT - RAY_MIN_HIT;
const float CAMERA_DEFAULT_FOCAL_DEPTH = RAY_DISTANCE / 3.0f;

float estimateFocalDepth()
{
#ifdef USE_DEPTH_MAP
    if (scene.frameChanged != 1) { // use the depth map of the previous frame
        vec2 sensorSize = gl_LaunchSizeEXT.xy / 128.0f;
        vec2 screenCenter = gl_LaunchSizeEXT.xy / 2.0f;
        float samp = imageLoad(imageDepth, ivec2(screenCenter.x, screenCenter.y - sensorSize.y)).r;
        samp += imageLoad(imageDepth, ivec2(screenCenter.x, screenCenter.y + sensorSize.y)).r;
        samp += imageLoad(imageDepth, ivec2(screenCenter)).r;
        samp += imageLoad(imageDepth, ivec2(screenCenter.x - sensorSize.x, screenCenter.y)).r;
        samp += imageLoad(imageDepth, ivec2(screenCenter.x + sensorSize.x, screenCenter.y)).r;
        samp /= 5.0f;
        return RAY_DISTANCE * samp;
    }
#endif
    return CAMERA_DEFAULT_FOCAL_DEPTH;
}

void main()
{
    vec3 result = vec3(0.0f);
    vec3 hitDistance = vec3(0.0f);
#ifdef DEPTH_OF_FIELD
    const float focalLength = estimateFocalDepth();
#endif
#ifdef SAMPLE_PRIMARY
    for (int n = 0; n < samples; ++n) {
#else
    const int n = 0;
    {
#endif
        // Initialize aux variables for iteration
        vec3 transportFactor = vec3(1.0f);
        vec3 sampleResult = vec3(0.0f);
        rayPayloadBRDF.seed
            = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, scene.frame + n);
        rayPayloadBRDF.done = 0;
        rayPayloadBRDF.surfaceAttenuation = vec3(1.0f);
        rayPayloadBRDF.surfaceRadiance = vec3(0.0f);
        rayPayloadBRDF.surfaceEmissive = vec3(0.0f);
        rayPayloadBRDF.rayType = RAY_TYPE_UNDEFINED;
        // ---

        // Antialiasing.
        const float r1 = rnd(rayPayloadBRDF.seed);
        const float r2 = rnd(rayPayloadBRDF.seed);
        const vec2 subpixelJitter
            = (scene.frameIteration + n) == 0 ? vec2(0.0f, 0.0f) : vec2(r1 - 0.5f, r2 - 0.5f);
        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5f) + subpixelJitter;
        const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
        const vec2 thetaOut = inUV * 2.0f - 1.0f;
        const vec4 target = scene.projInverse * vec4(thetaOut.x, thetaOut.y, 1.0f, 1.0f);
        // ---

        // Initial Origin and Direction
        vec3 origin = (scene.viewInverse * vec4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
        vec3 direction = (scene.viewInverse * vec4(normalize(target.xyz / target.w), 0.0f)).xyz;
        // ---

#ifdef DEPTH_OF_FIELD
        //	randomize the ray on the surface of the lense, going through the focal point
        float angle = r1 * 2.0 * M_PIf;
        float radius = r2;
        vec2 circPoint = vec2(cos(angle) * radius, sin(angle) * radius);
        vec3 apertureInc = vec3(circPoint.x * CAMERA_APERTURE, circPoint.y * CAMERA_APERTURE, 0.0f);
        origin += apertureInc;
        direction *= focalLength;
        direction -= apertureInc;
        direction = normalize(direction);
#endif

        // Direct Illum
        int depth = 0;
        float resultDistance;
        for (depth; depth < maxDepth; depth++) {
            trace_ray(origin, direction, AS_FLAG_EVERYTHING);
            origin = rayPayloadBRDF.nextRayOrigin;
            direction = rayPayloadBRDF.nextRayDirection;
            if (depth == 0) {
                resultDistance = rayPayloadBRDF.hitDistance;
            }
            if (rayPayloadBRDF.rayType == RAY_TYPE_DIFFUSE) {
                sampleResult
                    = rayPayloadBRDF.surfaceEmissive + rayPayloadBRDF.surfaceRadiance / M_PIf;
                transportFactor = rayPayloadBRDF.surfaceAttenuation;
                break;
            } else if (rayPayloadBRDF.rayType == RAY_TYPE_MISS) {
                sampleResult = rayPayloadBRDF.surfaceRadiance;
                // Not necessary because rayPayloadBRDF.done is 1 :
                //      transportFactor = rayPayloadBRDF.surfaceAttenuation;
                break;
            }
        }
        // End Direct Illum ---

#ifdef USE_DEPTH_MAP
        hitDistance += resultDistance / RAY_DISTANCE;
#endif

        // Indirect Illum
        for (depth; depth < maxDepth; depth++) {
            if (rayPayloadBRDF.done == 1) {
                break;
            }
            trace_ray(origin, direction, AS_FLAG_EVERYTHING);
            if (rayPayloadBRDF.rayType == RAY_TYPE_DIFFUSE) {
                sampleResult += rayPayloadBRDF.surfaceEmissive
                    + rayPayloadBRDF.surfaceRadiance * transportFactor;
                transportFactor *= rayPayloadBRDF.surfaceAttenuation;
                // Note: The PDF division is implicit here because for cosine sample
                // "PDF = cosTheta / PI":
                // => cosTheta is cancelled in "(Li * cosTheta * brdf) / PDF"
                // => (1 / PI) is cancelled in the division by PI.
                // As a result only the direct ilumination is divided by PI
            } else if (rayPayloadBRDF.rayType == RAY_TYPE_MISS) {
                sampleResult += rayPayloadBRDF.surfaceRadiance * transportFactor;
            }
            origin = rayPayloadBRDF.nextRayOrigin;
            direction = rayPayloadBRDF.nextRayDirection;
        }
        // End Indirect Illum ---
        // Clamp result
        result += min(sampleResult, vec3(1.0f));
        // ---
    }
#ifdef SAMPLE_PRIMARY
    result /= float(samples);
#ifdef USE_DEPTH_MAP
    hitDistance /= float(samples);
#endif
#endif

#ifdef SHOW_NANS
    // Error "handling"
    if (is_nan(result)) {
        result = vec3(1.0f, 0.0f, 0.0f);
    }
#endif

    // Do accumulation (imageColor should be rgba32f to avoid losing precision)
    if (scene.frameIteration > 0) {
        const float a = 1.0f / float(scene.frameIteration);
        const vec3 oldColor = imageLoad(imageColor, ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(imageColor, ivec2(gl_LaunchIDEXT.xy), vec4(mix(oldColor, result, a), 1.0f));
    } else {
        imageStore(imageColor, ivec2(gl_LaunchIDEXT.xy), vec4(result, 1.0f));
    }
#ifdef USE_DEPTH_MAP
    imageStore(imageDepth, ivec2(gl_LaunchIDEXT.xy), vec4(hitDistance, 1.0f));
#endif
}
